'use client'

import { useState, useEffect } from 'react'
import { css } from '../../styled-system/css'

interface ServerSorobanSVGProps {
  number: number
  colorScheme?: 'monochrome' | 'place-value' | 'heaven-earth' | 'alternating'
  hideInactiveBeads?: boolean
  beadShape?: 'diamond' | 'circle' | 'square'
  width?: number
  height?: number
  className?: string
}

export function ServerSorobanSVG({
  number,
  colorScheme = 'place-value',
  hideInactiveBeads = false,
  beadShape = 'diamond',
  width = 240,
  height = 320,
  className = ''
}: ServerSorobanSVGProps) {
  const [svgContent, setSvgContent] = useState<string>('')
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    const generateSVG = async () => {
      setIsLoading(true)
      setError(null)

      try {
        const config = {
          range: number.toString(),
          colorScheme,
          hideInactiveBeads,
          beadShape,
          format: 'svg'
        }

        const response = await fetch('/api/preview', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(config),
        })

        if (response.ok) {
          const data = await response.json()
          // Find the SVG for our specific number
          const sample = data.samples?.find((s: any) => s.number === number)
          if (sample?.front) {
            setSvgContent(sample.front)
          } else {
            throw new Error('No SVG found for number')
          }
        } else {
          throw new Error('SVG generation failed')
        }
      } catch (err) {
        console.error(`Failed to generate SVG for ${number}:`, err)
        setError('Unable to generate SVG')
        // Use fallback placeholder
        setSvgContent(generateFallbackSVG(number, width, height))
      } finally {
        setIsLoading(false)
      }
    }

    generateSVG()
  }, [number, colorScheme, hideInactiveBeads, beadShape])

  if (isLoading) {
    return (
      <div className={`${className} ${css({
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        color: 'gray.400',
        fontSize: 'sm'
      })}`}>
        <div className={css({
          w: '4',
          h: '4',
          border: '2px solid',
          borderColor: 'gray.300',
          borderTopColor: 'transparent',
          rounded: 'full',
          animation: 'spin 1s linear infinite',
          mr: '2'
        })} />
        Loading...
      </div>
    )
  }

  if (error) {
    return (
      <div className={`${className} ${css({
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        color: 'gray.400',
        fontSize: 'sm',
        gap: '1'
      })}`}>
        <div className={css({ fontSize: '2xl' })}>ðŸ§®</div>
        <div>Soroban for {number}</div>
      </div>
    )
  }

  // Process the SVG to ensure proper scaling
  const processedSVG = svgContent ? processSVGForDisplay(svgContent, width, height) : ''

  return (
    <div
      className={className}
      dangerouslySetInnerHTML={{ __html: processedSVG }}
    />
  )
}

function processSVGForDisplay(svgContent: string, targetWidth: number, targetHeight: number): string {
  // Parse the SVG to fix dimensions and viewBox if needed
  try {
    // Extract current width, height, and viewBox
    const widthMatch = svgContent.match(/width="([^"]*)"/)
    const heightMatch = svgContent.match(/height="([^"]*)"/)
    const viewBoxMatch = svgContent.match(/viewBox="([^"]*)"/)

    let processedSVG = svgContent

    // If the SVG doesn't have proper dimensions, set them
    if (widthMatch && heightMatch) {
      const currentWidth = parseFloat(widthMatch[1])
      const currentHeight = parseFloat(heightMatch[1])

      // Replace with target dimensions while preserving aspect ratio
      processedSVG = processedSVG
        .replace(/width="[^"]*"/, `width="${targetWidth}"`)
        .replace(/height="[^"]*"/, `height="${targetHeight}"`)

      // Special handling for soroban SVGs generated by Typst
      // These have complex transforms that push content outside the original viewBox
      if (viewBoxMatch && processedSVG.includes('matrix(4 0 0 4 -37.5 -180)')) {
        // This is a generated soroban SVG with known transform issues
        // Let's analyze the actual content positioning more carefully

        // The transforms are:
        // 1. translate(6 6) - base offset
        // 2. translate(41.5 14) - content positioning
        // 3. matrix(4 0 0 4 -37.5 -180) - scale 4x, translate -37.5, -180

        // After matrix transform, the content coordinate (0,17) becomes:
        // x: (0 * 4) + (-37.5) = -37.5
        // y: (17 * 4) + (-180) = -112
        // Plus the initial translates: x: -37.5 + 41.5 + 6 = 10, y: -112 + 14 + 6 = -92

        // So the actual top of content is around y = -92, and extends down ~290 units
        const actualContentTop = -92
        const contentHeight = 290

        // Create a tight viewBox around the actual content
        const padding = 10  // Reduced padding
        const newX = -padding
        const newY = actualContentTop - padding  // Start just above actual content
        const newWidth = currentWidth + (padding * 2)
        const newHeight = contentHeight + (padding * 2)

        const newViewBox = `${newX} ${newY} ${newWidth} ${newHeight}`
        processedSVG = processedSVG.replace(/viewBox="[^"]*"/, `viewBox="${newViewBox}"`)
      } else if (viewBoxMatch) {
        // Standard viewBox adjustment for other SVGs
        const viewBoxValues = viewBoxMatch[1].split(' ').map(v => parseFloat(v))
        if (viewBoxValues.length === 4) {
          const [x, y, width, height] = viewBoxValues
          const paddingX = width * 0.05
          const paddingY = height * 0.08
          const newViewBox = `${x - paddingX} ${y - paddingY} ${width + (paddingX * 2)} ${height + (paddingY * 2)}`
          processedSVG = processedSVG.replace(/viewBox="[^"]*"/, `viewBox="${newViewBox}"`)
        }
      } else {
        // If no viewBox exists, create one with padding
        const paddingX = currentWidth * 0.05
        const paddingY = currentHeight * 0.08
        const newViewBox = `${-paddingX} ${-paddingY} ${currentWidth + (paddingX * 2)} ${currentHeight + (paddingY * 2)}`
        processedSVG = processedSVG.replace('<svg', `<svg viewBox="${newViewBox}"`)
      }
    }

    // Ensure the SVG has responsive attributes for proper scaling
    if (!processedSVG.includes('preserveAspectRatio')) {
      processedSVG = processedSVG.replace('<svg', '<svg preserveAspectRatio="xMidYMid meet"')
    }

    return processedSVG
  } catch (error) {
    console.warn('Failed to process SVG:', error)
    return svgContent // Return original if processing fails
  }
}

function generateFallbackSVG(number: number, width: number, height: number): string {
  // Simple fallback SVG showing the number
  return `<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid meet">
    <rect x="10" y="10" width="${width-20}" height="${height-20}" fill="none" stroke="#8B4513" stroke-width="3"/>
    <line x1="15" y1="${height/2}" x2="${width-15}" y2="${height/2}" stroke="#8B4513" stroke-width="3"/>
    <text x="${width/2}" y="${height/2 + 40}" text-anchor="middle" font-size="24" fill="#666">
      ${number}
    </text>
  </svg>`
}