import { readFileSync } from 'fs'
import { join } from 'path'
import { db, schema } from '@/db'
import { bufferToEmbedding, EMBEDDING_DIMENSIONS } from './embedding'

/**
 * Topic taxonomy for labeling flowchart clusters.
 *
 * In production, the taxonomy is stored in the database (`topic_taxonomy` table)
 * and can be regenerated via the admin panel.
 *
 * In development, the taxonomy falls back to static files generated by
 * `scripts/generateTopicTaxonomy.ts` if the database is empty.
 *
 * At runtime, the browse API loads the taxonomy once and includes all label
 * embeddings in the distance matrix alongside flowchart embeddings. The client
 * then assigns the nearest label to each cluster.
 */

export interface Taxonomy {
  labels: string[]
  embeddings: Float32Array[]
  breadths: number[]
}

interface TaxonomyIndex {
  version: string
  model: string
  labels: string[]
}

const LABEL_PREFIX = 'label:'

let cachedTaxonomy: Taxonomy | null = null

/**
 * Clear the taxonomy cache. Call this after regenerating the taxonomy.
 */
export function clearTaxonomyCache(): void {
  cachedTaxonomy = null
}

/**
 * Load the topic taxonomy from database (preferred) or disk (fallback).
 * Cached after first call.
 */
export async function loadTaxonomy(): Promise<Taxonomy> {
  if (cachedTaxonomy) return cachedTaxonomy

  // Try loading from database first
  const dbTaxonomy = await loadTaxonomyFromDb()
  if (dbTaxonomy) {
    cachedTaxonomy = dbTaxonomy
    return cachedTaxonomy
  }

  // Fall back to files (for development or if DB is empty)
  cachedTaxonomy = loadTaxonomyFromFiles()
  return cachedTaxonomy
}

/**
 * Load taxonomy from database.
 * Returns null if the database has no taxonomy entries.
 */
async function loadTaxonomyFromDb(): Promise<Taxonomy | null> {
  const rows = await db.select().from(schema.topicTaxonomy)

  if (rows.length === 0) {
    return null
  }

  const labels: string[] = []
  const embeddings: Float32Array[] = []
  const breadths: number[] = []

  for (const row of rows) {
    labels.push(row.label)
    embeddings.push(bufferToEmbedding(row.embedding))
    breadths.push(row.breadth ?? 0) // Default to 0 if not set (legacy data)
  }

  return { labels, embeddings, breadths }
}

/**
 * Load taxonomy from static files.
 * Reads `topic-taxonomy.json` (label index) and `topic-taxonomy.bin`
 * (packed Float32Array embeddings, 1536 floats per label).
 */
function loadTaxonomyFromFiles(): Taxonomy {
  const dir = join(process.cwd(), 'src/lib/flowcharts')
  const indexPath = join(dir, 'topic-taxonomy.json')
  const binPath = join(dir, 'topic-taxonomy.bin')

  const index: TaxonomyIndex = JSON.parse(readFileSync(indexPath, 'utf-8'))
  const binBuffer = readFileSync(binPath)

  const embeddings: Float32Array[] = []
  const bytesPerLabel = EMBEDDING_DIMENSIONS * Float32Array.BYTES_PER_ELEMENT // 6144

  for (let i = 0; i < index.labels.length; i++) {
    const offset = i * bytesPerLabel
    const slice = binBuffer.subarray(offset, offset + bytesPerLabel)
    // Copy into a fresh ArrayBuffer so the Float32Array is properly aligned
    const ab = new ArrayBuffer(bytesPerLabel)
    new Uint8Array(ab).set(slice)
    embeddings.push(new Float32Array(ab))
  }

  // Static files don't have breadth data - default to 0
  const breadths = new Array(index.labels.length).fill(0)

  return { labels: index.labels, embeddings, breadths }
}

/** Build a label ID from a label string (e.g. "label:Fraction Arithmetic") */
export function labelId(label: string): string {
  return `${LABEL_PREFIX}${label}`
}

/** Check if an ID is a taxonomy label ID */
export function isLabelId(id: string): boolean {
  return id.startsWith(LABEL_PREFIX)
}

/** Extract the label text from a label ID */
export function labelFromId(id: string): string {
  return id.slice(LABEL_PREFIX.length)
}
