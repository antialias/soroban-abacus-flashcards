/**
 * Test to reproduce delivery thrashing bug
 *
 * The bug: When a car is at a station for multiple frames (50ms intervals),
 * the delivery logic fires repeatedly before the optimistic state update propagates.
 * This causes multiple DELIVER_PASSENGER moves to be sent to the server,
 * which rejects all but the first one.
 */

import { describe, expect, test } from "vitest";

interface Passenger {
  id: string;
  name: string;
  claimedBy: string | null;
  deliveredBy: string | null;
  carIndex: number | null;
  destinationStationId: string;
  isUrgent: boolean;
}

interface Station {
  id: string;
  name: string;
  emoji: string;
  position: number;
}

describe("useSteamJourney - Delivery Thrashing Reproduction", () => {
  const CAR_SPACING = 7;

  /**
   * Simulate the delivery logic from useSteamJourney
   * Returns the number of delivery attempts made
   */
  function simulateDeliveryAtPosition(
    trainPosition: number,
    passengers: Passenger[],
    stations: Station[],
    pendingDeliveryRef: Set<string>,
  ): { deliveryAttempts: number; deliveredPassengerIds: string[] } {
    let deliveryAttempts = 0;
    const deliveredPassengerIds: string[] = [];

    const currentBoardedPassengers = passengers.filter(
      (p) => p.claimedBy !== null && p.deliveredBy === null,
    );

    // PRIORITY 1: Process deliveries FIRST (dispatch DELIVER moves before BOARD moves)
    currentBoardedPassengers.forEach((passenger) => {
      if (
        !passenger ||
        passenger.deliveredBy !== null ||
        passenger.carIndex === null
      )
        return;

      // Skip if already has a pending delivery request
      if (pendingDeliveryRef.has(passenger.id)) return;

      const station = stations.find(
        (s) => s.id === passenger.destinationStationId,
      );
      if (!station) return;

      // Calculate this passenger's car position using PHYSICAL carIndex
      const carPosition = Math.max(
        0,
        trainPosition - (passenger.carIndex + 1) * CAR_SPACING,
      );
      const distance = Math.abs(carPosition - station.position);

      // If this car is at the destination station (within 5% tolerance), deliver
      if (distance < 5) {
        // Mark as pending BEFORE dispatch to prevent duplicate delivery attempts across frames
        pendingDeliveryRef.add(passenger.id);
        deliveryAttempts++;
        deliveredPassengerIds.push(passenger.id);
      }
    });

    return { deliveryAttempts, deliveredPassengerIds };
  }

  test("WITHOUT fix: multiple frames at same position cause thrashing", () => {
    const stations: Station[] = [
      { id: "s1", name: "Start", emoji: "üè†", position: 20 },
      { id: "s2", name: "Middle", emoji: "üè¢", position: 40 },
      { id: "s3", name: "End", emoji: "üèÅ", position: 80 },
    ];

    // Passenger "Bob" is in Car 1, heading to station s2 at position 40
    const passengers: Passenger[] = [
      {
        id: "bob",
        name: "Bob",
        claimedBy: "player1",
        deliveredBy: null, // Not yet delivered
        carIndex: 1, // In car 1 (second car)
        destinationStationId: "s2",
        isUrgent: false,
      },
    ];

    // NO pending delivery tracking (simulating the bug)
    const noPendingRef = new Set<string>();

    // Train position where Car 1 is at station s2 (position 40)
    // Car 1 position = trainPosition - (carIndex + 1) * CAR_SPACING
    // Car 1 position = trainPosition - 2 * 7 = trainPosition - 14
    // For Car 1 to be at position 40: trainPosition = 40 + 14 = 54
    const trainPosition = 53.9;

    const carPosition = Math.max(0, trainPosition - (1 + 1) * CAR_SPACING);
    console.log(
      `Train at ${trainPosition}, Car 1 at ${carPosition}, Station at 40`,
    );
    expect(Math.abs(carPosition - 40)).toBeLessThan(5); // Verify we're in delivery range

    let totalAttempts = 0;

    // Simulate 10 frames (50ms each = 500ms total) at the same position
    // This mimics what happens when the train is near/at a station
    for (let frame = 0; frame < 10; frame++) {
      const result = simulateDeliveryAtPosition(
        trainPosition,
        passengers,
        stations,
        noPendingRef,
      );
      totalAttempts += result.deliveryAttempts;

      // WITHOUT the pendingDeliveryRef fix, every frame triggers a delivery attempt
      // because the optimistic update hasn't propagated yet
    }

    // Without the fix, we expect 10 delivery attempts (one per frame)
    // because nothing prevents duplicate attempts
    console.log(`Total delivery attempts without fix: ${totalAttempts}`);
    expect(totalAttempts).toBe(10); // This demonstrates the bug!
  });

  test("WITH fix: pendingDeliveryRef prevents thrashing", () => {
    const stations: Station[] = [
      { id: "s1", name: "Start", emoji: "üè†", position: 20 },
      { id: "s2", name: "Middle", emoji: "üè¢", position: 40 },
      { id: "s3", name: "End", emoji: "üèÅ", position: 80 },
    ];

    const passengers: Passenger[] = [
      {
        id: "bob",
        name: "Bob",
        claimedBy: "player1",
        deliveredBy: null,
        carIndex: 1,
        destinationStationId: "s2",
        isUrgent: false,
      },
    ];

    // WITH pending delivery tracking (the fix)
    const pendingDeliveryRef = new Set<string>();

    const trainPosition = 53.9;

    let totalAttempts = 0;

    // Simulate 10 frames at the same position
    for (let frame = 0; frame < 10; frame++) {
      const result = simulateDeliveryAtPosition(
        trainPosition,
        passengers,
        stations,
        pendingDeliveryRef,
      );
      totalAttempts += result.deliveryAttempts;
    }

    // With the fix, only the FIRST frame should attempt delivery
    // All subsequent frames skip because passenger.id is in pendingDeliveryRef
    console.log(`Total delivery attempts with fix: ${totalAttempts}`);
    expect(totalAttempts).toBe(1); // Only one attempt! ‚úÖ
  });

  test("EDGE CASE: multiple passengers at same station", () => {
    const stations: Station[] = [
      { id: "s1", name: "Start", emoji: "üè†", position: 20 },
      { id: "s2", name: "Middle", emoji: "üè¢", position: 40 },
      { id: "s3", name: "End", emoji: "üèÅ", position: 80 },
    ];

    // Two passengers in different cars, both going to station s2
    const passengers: Passenger[] = [
      {
        id: "alice",
        name: "Alice",
        claimedBy: "player1",
        deliveredBy: null,
        carIndex: 0, // Car 0
        destinationStationId: "s2",
        isUrgent: false,
      },
      {
        id: "bob",
        name: "Bob",
        claimedBy: "player1",
        deliveredBy: null,
        carIndex: 1, // Car 1
        destinationStationId: "s2",
        isUrgent: false,
      },
    ];

    const pendingDeliveryRef = new Set<string>();

    // Position where both cars are near station s2 (position 40)
    // Car 0 at position 40: trainPosition = 40 + 7 = 47
    // Car 1 at position 40: trainPosition = 40 + 14 = 54
    // Let's use 50 so Car 0 is at 43 and Car 1 is at 36 (both within 5 of 40)
    const trainPosition = 46.5;

    // Debug: Check car positions
    const car0Pos = Math.max(0, trainPosition - (0 + 1) * CAR_SPACING);
    const car1Pos = Math.max(0, trainPosition - (1 + 1) * CAR_SPACING);
    console.log(
      `Train at ${trainPosition}, Car 0 at ${car0Pos} (dist ${Math.abs(car0Pos - 40)}), Car 1 at ${car1Pos} (dist ${Math.abs(car1Pos - 40)})`,
    );

    let totalAttempts = 0;

    // Simulate 5 frames
    for (let frame = 0; frame < 5; frame++) {
      const result = simulateDeliveryAtPosition(
        trainPosition,
        passengers,
        stations,
        pendingDeliveryRef,
      );
      totalAttempts += result.deliveryAttempts;
      if (result.deliveryAttempts > 0) {
        console.log(
          `Frame ${frame}: Delivered ${result.deliveredPassengerIds.join(", ")}`,
        );
      }
    }

    // Should deliver BOTH passengers exactly once (2 total attempts)
    console.log(`Total delivery attempts for 2 passengers: ${totalAttempts}`);
    expect(totalAttempts).toBe(2); // Alice once, Bob once ‚úÖ
  });
});
